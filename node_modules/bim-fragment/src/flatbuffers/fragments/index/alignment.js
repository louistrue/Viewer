// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';
import { CivilCurve } from '../../fragments/index/civil-curve.js';
export class Alignment {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsAlignment(bb, obj) {
        return (obj || new Alignment()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsAlignment(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Alignment()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    vertical(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? (obj || new CivilCurve()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    verticalLength() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    horizontal(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new CivilCurve()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    horizontalLength() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    absolute(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new CivilCurve()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    absoluteLength() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    initialPk() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    static startAlignment(builder) {
        builder.startObject(4);
    }
    static addVertical(builder, verticalOffset) {
        builder.addFieldOffset(0, verticalOffset, 0);
    }
    static createVerticalVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startVerticalVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addHorizontal(builder, horizontalOffset) {
        builder.addFieldOffset(1, horizontalOffset, 0);
    }
    static createHorizontalVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startHorizontalVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addAbsolute(builder, absoluteOffset) {
        builder.addFieldOffset(2, absoluteOffset, 0);
    }
    static createAbsoluteVector(builder, data) {
        builder.startVector(4, data.length, 4);
        for (let i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    }
    static startAbsoluteVector(builder, numElems) {
        builder.startVector(4, numElems, 4);
    }
    static addInitialPk(builder, initialPk) {
        builder.addFieldFloat32(3, initialPk, 0.0);
    }
    static endAlignment(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createAlignment(builder, verticalOffset, horizontalOffset, absoluteOffset, initialPk) {
        Alignment.startAlignment(builder);
        Alignment.addVertical(builder, verticalOffset);
        Alignment.addHorizontal(builder, horizontalOffset);
        Alignment.addAbsolute(builder, absoluteOffset);
        Alignment.addInitialPk(builder, initialPk);
        return Alignment.endAlignment(builder);
    }
}
//# sourceMappingURL=alignment.js.map